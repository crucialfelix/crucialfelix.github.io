<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chris Sattinger</title><link>https://crucialfelix.github.io/posts/</link><description>Recent content in Posts on Chris Sattinger</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://crucialfelix.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Renaming database columns in production</title><link>https://crucialfelix.github.io/posts/renaming-database-columns-in-production/</link><pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><guid>https://crucialfelix.github.io/posts/renaming-database-columns-in-production/</guid><description>Let&amp;rsquo;s say you want to rename a database field on table blog_post from created to created_at. Everyone keeps thinking createdis a BOOLEAN (and then asking you what the point of that is) and you just want it to be nice and consistent.
You can&amp;rsquo;t just write a data migration, renaming the database field and changing usages in the codes base and then simply deploy that to production.
While your new release is rolling out you will have two versions of the application running at the same time: the current version (using created) and the next version (which uses created_at).</description><content>&lt;p>Let&amp;rsquo;s say you want to rename a database field on table &lt;code>blog_post&lt;/code> from &lt;code>created&lt;/code> to &lt;code>created_at&lt;/code>. Everyone keeps thinking &lt;code>created&lt;/code>is a &lt;code>BOOLEAN&lt;/code> (and then asking you what the point of that is) and you just want it to be nice and consistent.&lt;/p>
&lt;p>You can&amp;rsquo;t just write a data migration, renaming the database field and changing usages in the codes base and then simply deploy that to production.&lt;/p>
&lt;p>While your new release is rolling out you will have two versions of the application running at the same time: the current version (using &lt;code>created&lt;/code>) and the next version (which uses &lt;code>created_at&lt;/code>).&lt;/p>
&lt;p>&lt;strong>When the data migration runs, the currently running app will throw database errors even on select as the column with that name no longer exist.&lt;/strong>&lt;/p>
&lt;p>The correct approach is to implement and deploy this in a release:&lt;/p>
&lt;ol>
&lt;li>Add new column &lt;code>created_at&lt;/code>&lt;/li>
&lt;li>Copy the old column data to the new column:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">&lt;span style="color:#66d9ef">UPDATE&lt;/span> blog_post &lt;span style="color:#66d9ef">SET&lt;/span> created_at &lt;span style="color:#f92672">=&lt;/span> created;
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Change all usages in codebase to the new field name&lt;/li>
&lt;/ol>
&lt;p>After you deploy this (assuming you always run migrations during a deploy) you will have two columns. The app will only read and write to &lt;code>created_at&lt;/code>&lt;/p>
&lt;p>In the next release you can drop column &lt;code>created&lt;/code>.&lt;/p>
&lt;p>Now it is still possible that in the seconds just after the migration was executed, the old still running version managed to process one more insert which only sets &lt;code>created&lt;/code>. If you are on a high traffic site then it&amp;rsquo;s guaranteed to be a problem.&lt;/p>
&lt;p>In this particular case, &lt;code>created_at&lt;/code> would probably have a default of &lt;code>NOW()&lt;/code>, but what if we are migrating from &lt;code>org&lt;/code> -&amp;gt; &lt;code>company&lt;/code>?&lt;/p>
&lt;p>You could put some temporary glue code in to use &lt;code>company&lt;/code> or &lt;code>org&lt;/code> when reading the model:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">company &lt;span style="color:#f92672">=&lt;/span> blog_post&lt;span style="color:#f92672">.&lt;/span>company &lt;span style="color:#f92672">or&lt;/span> blog_post&lt;span style="color:#f92672">.&lt;/span>org
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Remove that in the subsequent release.&lt;/p>
&lt;p>You might think that you could install a temporary trigger to keep it updated:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">or&lt;/span> &lt;span style="color:#66d9ef">replace&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> trigger_on_blog_post()
&lt;span style="color:#66d9ef">returns&lt;/span> &lt;span style="color:#66d9ef">trigger&lt;/span> &lt;span style="color:#66d9ef">language&lt;/span> plpgsql &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">$$&lt;/span>
&lt;span style="color:#66d9ef">begin&lt;/span>
&lt;span style="color:#66d9ef">new&lt;/span>.created_at :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>.created;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>;
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">$$&lt;/span>;
&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">trigger&lt;/span> trigger_on_blog_post
&lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span> &lt;span style="color:#66d9ef">or&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span> blog_post
&lt;span style="color:#75715e">-- for each row execute procedure trigger_on_example();
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The problem here is that once the new app goes live then it&amp;rsquo;s copying the wrong direction! By this point you probably want to report back to your team that we should just live with the bad name.&lt;/p>
&lt;p>If you have a lot of fields to rename, if you have tables to rename, or if you have many types to fix then you should plan to migrate the data to a new schema using something like &lt;a href="https://www.getdbt.com/">dbt&lt;/a> and make the switch with a breif scheduled maintenance. This is going to be far faster and less error prone then trying to fix every single problem sequentially.&lt;/p></content></item></channel></rss>